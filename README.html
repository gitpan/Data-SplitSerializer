<html><head><title>Data::SplitSerializer</title>
<meta http-equiv="Content-Type" content="text/html; charset=ISO-8859-1" >
</head>
<body class='pod'>
<!--
  generated by Pod::Simple::HTML v3.22,
  using Pod::Simple::PullParser v3.22,
  under Perl v5.014002 at Fri Aug  9 00:07:28 2013 GMT.

 If you want to change this HTML document, you probably shouldn't do that
   by changing it directly.  Instead, see about changing the calling options
   to Pod::Simple::HTML, and/or subclassing Pod::Simple::HTML,
   then reconverting this document from the Pod source.
   When in doubt, email the author of Pod::Simple::HTML for advice.
   See 'perldoc Pod::Simple::HTML' for more info.

-->

<!-- start doc -->
<a name='___top' class='dummyTopAnchor' ></a>

<h1><a class='u'
name="NAME"
>NAME</a></h1>

<p>Data::SplitSerializer - Modules that &#34;split serialize&#34; data structures</p>

<h1><a class='u'
name="SYNOPSIS"
>SYNOPSIS</a></h1>

<pre>    use Data::SplitSerializer;
 
    my $dss = Data::SplitSerializer-&#62;new( path_style =&#62; &#39;DZIL&#39; );
    my $serialized = {
       &#39;gophers[0].holes&#39;      =&#62; 3,
       &#39;gophers[0].food.type&#39;  =&#62; &#39;grubs&#39;,
       &#39;gophers[0].food.count&#39; =&#62; 7,
 
       &#39;gophers[1].holes&#39;      =&#62; 1,
       &#39;gophers[1].food.type&#39;  =&#62; &#39;fruit&#39;,
       &#39;gophers[1].food.count&#39; =&#62; 5,
    };
    my $deserialized = $dss-&#62;deserialize($serialized);
 
    my $more_gophers = [];
    $more_gophers-&#62;[2] = {
       holes =&#62; 2,
       food  =&#62; {
          type  =&#62; &#39;earthworms&#39;,
          count =&#62; 15,
       },
    };
 
    $deserialized = $dss-&#62;merge( $deserialized, $more_gophers );</pre>

<h1><a class='u'
name="DESCRIPTION"
>DESCRIPTION</a></h1>

<p>Split serialization is a unique form of serialization that only serializes part of the data structure (as a path on the left side) and leaves the rest of the data, typically a scalar, untouched (as a value on the right side). Consider the gopher example above:</p>

<pre>    my $deserialized = {
       gophers =&#62; [
          {
             holes =&#62; 3,
             food  =&#62; {
                type  =&#62; &#39;grubs&#39;,
                count =&#62; 7,
             },
          },
          {
             holes =&#62; 1,
             food  =&#62; {
                type  =&#62; &#39;fruit&#39;,
                count =&#62; 5,
             },
          },
          {
             holes =&#62; 2,
             food  =&#62; {
                type  =&#62; &#39;earthworms&#39;,
                count =&#62; 15,
             },
          }
       ],
    };</pre>

<p>A full serializer, like <a href="http://search.cpan.org/perldoc?Data%3A%3ASerializer" class="podlinkpod"
>Data::Serializer</a> or <a href="http://search.cpan.org/perldoc?Data%3A%3ADumper" class="podlinkpod"
>Data::Dumper</a>, would turn the entire object into a string, much like the real code above. Or into JSON, XML, BerkleyDB, etc. But, the end values would be lost in the stream. If you were given an object like this, how would you be able to store the data in an easy-to-access form for a caching module like <a href="http://search.cpan.org/perldoc?CHI" class="podlinkpod"
>CHI</a>? It requires key/value pairs. Same goes for <a href="http://search.cpan.org/perldoc?KiokuDB" class="podlinkpod"
>KiokuDB</a> or various other storage/ORM modules.</p>

<p>Data::SplitSerializer uses split serialization to turn the data into a path like this:</p>

<pre>    my $serialized = {
       &#39;gophers[0].holes&#39;      =&#62; 3,
       &#39;gophers[0].food.type&#39;  =&#62; &#39;grubs&#39;,
       &#39;gophers[0].food.count&#39; =&#62; 7,
 
       &#39;gophers[1].holes&#39;      =&#62; 1,
       &#39;gophers[1].food.type&#39;  =&#62; &#39;fruit&#39;,
       &#39;gophers[1].food.count&#39; =&#62; 5,
 
       &#39;gophers[2].holes&#39;      =&#62; 2,
       &#39;gophers[2].food.type&#39;  =&#62; &#39;earthworms&#39;,
       &#39;gophers[2].food.count&#39; =&#62; 15,
    };</pre>

<p>Now, you can stash the data into whatever storage engine you want... or use just use it as a simple hash.</p>

<h1><a class='u'
name="CONSTRUCTOR"
>CONSTRUCTOR</a></h1>

<pre>    # Defaults shown
    my $stash = Data::Stash-&#62;new(
       path_style   =&#62; &#39;DZIL&#39;,
       path_options =&#62; {
          auto_normalize =&#62; 1,
          auto_cleanup   =&#62; 1,
       },
    );</pre>

<p>Creates a new serializer object. Accepts the following arguments:</p>

<h2><a class='u'
name="path_style"
>path_style</a></h2>

<pre>    path_style =&#62; &#39;File::Unix&#39;
    path_style =&#62; &#39;=MyApp::Parse::Path::Foobar&#39;</pre>

<p>Class used to create new <a href="http://search.cpan.org/perldoc?Parse%3A%3APath" class="podlinkpod"
>path objects</a> for path parsing. With a <code>=</code> prefix, it will use that as the full class. Otherwise, the class will be intepreted as <code>Parse::Path::$class</code>.</p>

<p>Default is <a href="http://search.cpan.org/perldoc?Parse%3A%3APath%3A%3ADZIL" class="podlinkpod"
>DZIL</a>.</p>

<h2><a class='u'
name="path_options"
>path_options</a></h2>

<pre>    path_options =&#62; {
       auto_normalize =&#62; 1,
       auto_cleanup   =&#62; 1,
    }</pre>

<p>Hash of options to pass to new path objects. Typically, the default set of options are recommended to ensure a more commutative path.</p>

<h2><a class='u'
name="remove_undefs"
>remove_undefs</a></h2>

<pre>    remove_undefs =&#62; 0</pre>

<p>Boolean to indicate whether to remove See <a href="#Undefined_values" class="podlinkpod"
>&#34;Undefined values&#34;</a> for more information.</p>

<p>Default is on.</p>

<h1><a class='u'
name="METHODS"
>METHODS</a></h1>

<h2><a class='u'
name="serialize"
>serialize</a></h2>

<pre>    my $serialized = $dss-&#62;serialize($deserialized);</pre>

<p>Serializes/flattens a ref. Returns a serialized hashref of path/value pairs.</p>

<h2><a class='u'
name="serialize_refpath"
>serialize_refpath</a></h2>

<pre>    my $serialized = $dss-&#62;serialize_refpath($path_prefix, $deserialized);
 
    # serialize is basically this with some extra sanity checks
    my $serialized = $dss-&#62;serialize_refpath(&#39;&#39;, $deserialized);</pre>

<p>The real workhorse for <code>serialize_ref</code>. Recursively dives down the different pieces of the deserialized tree and eventually comes back with the serialized hashref. The path prefix can be used for prepending all of the paths returned in the serialized hashref.</p>

<h2><a class='u'
name="deserialize"
>deserialize</a></h2>

<pre>    my $deserialized = $dss-&#62;deserialize($serialized);</pre>

<p>Deserializes/expands a hash of path/data pairs. Returns the expanded object, which is usually a hashref, but might be an arrayref. For example:</p>

<pre>    # Starts with an array
    my $serialized = {
       &#39;[0].thingy&#39; =&#62; 1,
       &#39;[1].thingy&#39; =&#62; 2,
    };
    my $deserialized = $dss-&#62;deserialize($serialized);
 
    # Returns:
    $deserialized = [
       { thingy =&#62; 1 },
       { thingy =&#62; 2 },
    ];</pre>

<h2><a class='u'
name="deserialize_pathval"
>deserialize_pathval</a></h2>

<pre>    my $deserialized = $dss-&#62;deserialize_pathval($path, $value);</pre>

<p>Deserializes/expands a single path/data pair. Returns the expanded object.</p>

<h2><a class='u'
name="merge"
>merge</a></h2>

<pre>    my $newhash = $dss-&#62;merge($hash1, $hash2);</pre>

<p>Merges two hashes. This is a direct handle to <code>merge</code> from an (internal) <a href="http://search.cpan.org/perldoc?Hash%3A%3AMerge" class="podlinkpod"
>Hash::Merge</a> object, and is used by <a href="#deserialize" class="podlinkpod"
>&#34;deserialize&#34;</a> to combine individual expanded objects.</p>

<h2><a class='u'
name="set_merge_behavior"
>set_merge_behavior</a></h2>

<p>Handle to <code>set_behavior</code> from the (internal) <a href="http://search.cpan.org/perldoc?Hash%3A%3AMerge" class="podlinkpod"
>Hash::Merge</a> object. <b>Advanced usage only!</b></p>

<p>Data::SplitSerializer uses a special custom type called <code>LEFT_PRECEDENT_STRICT_ARRAY_INDEX</code>, which properly handles array indexes and dies on any non-array-or-hash refs.</p>

<h2><a class='u'
name="specify_merge_behavior"
>specify_merge_behavior</a></h2>

<p>Handle to <code>specify_behavior</code> from the (internal) <a href="http://search.cpan.org/perldoc?Hash%3A%3AMerge" class="podlinkpod"
>Hash::Merge</a> object. <b>Advanced usage only!</b></p>

<h1><a class='u'
name="CAVEATS"
>CAVEATS</a></h1>

<h2><a class='u'
name="Undefined_values"
>Undefined values</a></h2>

<p>Flattening will remove path/values if the value is undefined. This is to clean up unused array values that appeared as holes in a sparse array. For example:</p>

<pre>    # From one of the basic tests
    my $round_trip = $dss-&#62;serialize( $dss-&#62;deserialize_pathval(
       &#39;a[0][1][1][1][1][2].too&#39; =&#62; &#39;long&#39;
    ) );
 
    # Without undef removal, this returns:
    $round_trip = {
       &#39;a[0][0]&#39;                 =&#62; undef,
       &#39;a[0][1][0]&#39;              =&#62; undef,
       &#39;a[0][1][1][0]&#39;           =&#62; undef,
       &#39;a[0][1][1][1][0]&#39;        =&#62; undef,
       &#39;a[0][1][1][1][1][0]&#39;     =&#62; undef,
       &#39;a[0][1][1][1][1][1]&#39;     =&#62; undef,
       &#39;a[0][1][1][1][1][2].too&#39; =&#62; &#39;long&#39;,
    };</pre>

<p>You can disable this with the <a href="#remove_undefs" class="podlinkpod"
>&#34;remove_undefs&#34;</a> switch.</p>

<h2><a class='u'
name="Refs_in_split_serialization"
>Refs in split serialization</a></h2>

<p>Split serialization works by looking for HASH or ARRAY refs and diving further into them, adding path prefixes as it goes down. If it encounters some other ref (like a SCALAR), it will stop and consider that to be the value for that path. In terms of ref parsing, this means two things:</p>

<ol>
<li>Only HASH and ARRAYs can be examined deeper.</li>

<li>If you have a HASH or ARRAY as a &#34;value&#34;, serialization cannot tell the difference and it will be included in the path.</li>
</ol>

<p>The former isn&#39;t that big of a problem, since deeper dives with other kinds of refs are either not possible or dangerous (like CODE).</p>

<p>The latter could be a problem if you started with a hashref with a path/data pair, expanded it, and tried to flatten it again. This can be solved by protecting the hash with a REF. Consider this example:</p>

<pre>    my $round_trip = $dss-&#62;serialize( $dss-&#62;deserialize_pathval(
       &#39;a[0]&#39; =&#62; { your =&#62; &#39;hash&#39; }
    ) );
 
    # Returns:
    $round_trip = {
       &#39;a[0].your&#39; =&#62; &#39;hash&#39;,
    };
 
    # Now protect the hash
    my $round_trip = $dss-&#62;serialize( $dss-&#62;deserialize_pathval(
       &#39;a[0]&#39; =&#62; \{ your =&#62; &#39;hash&#39; }
    ) );
 
    # Returns:
    $round_trip = {
       &#39;a[0]&#39; =&#62; \{ your =&#62; &#39;hash&#39; }
    };</pre>

<h2><a class='u'
name="Sparse_arrays_and_memory_usage"
>Sparse arrays and memory usage</a></h2>

<p>Since arrays within paths are based on indexes, there&#39;s a potential security issue with large indexes causing abnormal memory usage. In Perl, these two arrays would have drastically different memory footprints:</p>

<pre>    my @small;
    $small[0] = 1;
 
    my @large;
    $large[999999] = 1;</pre>

<p>This can be mitigated by making sure the Path style you use will limit the total digits for array indexes. <a href="http://search.cpan.org/perldoc?Parse%3A%3APath" class="podlinkpod"
>Parse::Path</a> handles this on all of its paths, but it&#39;s something to be aware of if you create your own path classes.</p>

<h1><a class='u'
name="TODO"
>TODO</a></h1>

<p>This module might split off into individual split serializers, but so far, this is the only one &#34;out in the wild&#34;.</p>

<h1><a class='u'
name="SEE_ALSO"
>SEE ALSO</a></h1>

<p><a href="http://search.cpan.org/perldoc?Parse%3A%3APath" class="podlinkpod"
>Parse::Path</a></p>

<h1><a class='u'
name="ACKNOWLEDGEMENTS"
>ACKNOWLEDGEMENTS</a></h1>

<p>Kent Fredric for getting me started on the basic idea.</p>

<h1><a class='u'
name="AVAILABILITY"
>AVAILABILITY</a></h1>

<p>The project homepage is <a href="https://github.com/SineSwiper/Data-SplitSerializer/wiki" class="podlinkurl"
>https://github.com/SineSwiper/Data-SplitSerializer/wiki</a>.</p>

<p>The latest version of this module is available from the Comprehensive Perl Archive Network (CPAN). Visit <a href="http://www.perl.com/CPAN/" class="podlinkurl"
>http://www.perl.com/CPAN/</a> to find a CPAN site near you, or see <a href="https://metacpan.org/module/Data::SplitSerializer/" class="podlinkurl"
>https://metacpan.org/module/Data::SplitSerializer/</a>.</p>

<h1><a class='u'
name="SUPPORT"
>SUPPORT</a></h1>

<h2><a class='u'
name="Internet_Relay_Chat"
>Internet Relay Chat</a></h2>

<p>You can get live help by using IRC ( Internet Relay Chat ). If you don&#39;t know what IRC is, please read this excellent guide: <a href="http://en.wikipedia.org/wiki/Internet_Relay_Chat" class="podlinkurl"
>http://en.wikipedia.org/wiki/Internet_Relay_Chat</a>. Please be courteous and patient when talking to us, as we might be busy or sleeping! You can join those networks/channels and get help:</p>

<ul>
<li>irc.perl.org
<p>You can connect to the server at &#39;irc.perl.org&#39; and talk to this person for help: SineSwiper.</p>
</li>
</ul>

<h2><a class='u'
name="Bugs_/_Feature_Requests"
>Bugs / Feature Requests</a></h2>

<p>Please report any bugs or feature requests via <a href="https://github.com/SineSwiper/Data-SplitSerializer/issues" class="podlinkurl"
>https://github.com/SineSwiper/Data-SplitSerializer/issues</a>.</p>

<h1><a class='u'
name="AUTHOR"
>AUTHOR</a></h1>

<p>Brendan Byrd &#60;BBYRD@CPAN.org&#62;</p>

<h1><a class='u'
name="CONTRIBUTOR"
>CONTRIBUTOR</a></h1>

<p>Brendan Byrd &#60;bbyrd@cpan.org&#62;</p>

<h1><a class='u'
name="COPYRIGHT_AND_LICENSE"
>COPYRIGHT AND LICENSE</a></h1>

<p>This software is Copyright (c) 2013 by Brendan Byrd.</p>

<p>This is free software, licensed under:</p>

<pre>  The Artistic License 2.0 (GPL Compatible)</pre>

<!-- end doc -->

</body></html>
